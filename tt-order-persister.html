<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../app-pouchdb/app-pouchdb-index.html">
<link rel="import" href="../app-pouchdb/app-pouchdb-query.html">
<link rel="import" href="../app-pouchdb/app-pouchdb-document.html">
<link rel="import" href="../app-pouchdb/app-pouchdb-conflict-resolution.html">
<link rel="import" href="../app-pouchdb/app-pouchdb-sync.html">

<!--
`tt-order-persister`


@demo demo/index.html 
-->

<dom-module id="tt-order-persister">
    <template>
        <style>
            :host {
                display: block;
            }
        </style>

        <app-pouchdb-index name="[[dbName]]" fields="['num']"></app-pouchdb-index>
        <app-pouchdb-document id="orderDB"
                              db-name="[[dbName]]"
                              doc-id="parsnip"
                              data="{{data}}">
        </app-pouchdb-document>

        <h1 on-tap="testHmac">Hash</h1>
    </template>

    <script>
        Polymer({

            is: 'tt-order-persister',

            properties: {
                /**
                 * The name of the database. This can be either a local database (such
                 * as "cats"), or a remote one (e.g., "https://example.com:5678/cats").
                 */
                dbName: {
                    type: String,
                    value: 'orders',
                    readOnly: true,
                },
                order: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                },
                orderId: {
                    type: String
                }
            },
            _getCryptoSubtle: function () {
                var crypto = window.crypto || window.msCrypto; //for IE11
                if (crypto.webkitSubtle) {
                    return window.crypto.webkitSubtle; //for Safari
                }
                return crypto.subtle;
            },

            _generateCryptoKey: function () {
                var cryptoSubtle = this._getCryptoSubtle();
                //can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
                var algo = {name: "HMAC", hash: {name: "SHA-256"}};
                var promise = cryptoSubtle.generateKey(algo, true, ["sign", "verify"]);
                promise = promise.then(function (key) {
                    return cryptoSubtle.exportKey('jwk', key);
                }).then(function (jwk) {
                    console.log('jwk : ', jwk);
                    return jwk;
                }).catch(function (err) {
                    console.error(err);
                });
                return promise;
            },
            _convertDataToBuffer:function (data) {
                var buffer = new TextEncoder('utf-8').encode(JSON.stringify(data));
                return buffer;
            },
            _signHMAC: function (jwk, data) {
                var self = this;
                var algo = {name: "HMAC", hash: {name: "SHA-256"}};
                var cryptoSubtle = this._getCryptoSubtle();
                console.log('import jwk : ', jwk);
                var promise = cryptoSubtle.importKey('jwk', jwk, algo, true, ['sign']);
                promise =  promise.then(function (key) {
                    console.log('jwk read :', key);
                    var buffer = self._convertDataToBuffer(data);
                    return cryptoSubtle.sign(algo, key, buffer);
                }).then(function (mac) {
                    var macHex = self.toHexString(mac);
                    console.log('compute HMAC : ', macHex);
                    return macHex;
                });
                return promise;
            },
            _verifyHmac: function (jwk, macHex, data) {
                var self = this;
                var algo = {name: "HMAC", hash: {name: "SHA-256"}};
                var mac =  macHex;  //FIXME Convert to buffer
                var cryptoSubtle = this._getCryptoSubtle();
                var promise = cryptoSubtle.importKey('jwk', jwk, algo, true, ['verify']);
                promise = promise.then(function (key) {
                    var text2verify = self._convertDataToBuffer(data);
                    return  cryptoSubtle.verify(algo, key, mac, text2verify);
                });
                return promise;

            },

            testHmac: function () {
                var self = this;
                var data = 'coucou tous le monde';
                var jwkSave;
//                this.saveOrder('coucou');
                // generate Key
                var promiseJwk = this._generateCryptoKey();
                //Sign
                var promiseSign = promiseJwk.then(function (jwk) {
                    jwkSave = jwk;
                    return self._signHMAC(jwk, data);
                });
                // Verify
                var promiseVerify =promiseSign.then(function (macHex) {
                    return self._verifyHmac(jwkSave, macHex, data);
                }).then(function (isValid) {
                    console.log('isValid : ', isValid);
                });
            },

            toHexString: function (buffer) {
                var byteArray = new Uint8Array(buffer);
                return byteArray.map(function (byte) {
                    return ('0' + (byte & 0xFF).toString(16)).slice(-2);
                }).join('')
            },
            saveOrder: function (model) {
                var cryptoSubtle = this._getCryptoSubtle();
                this.order = model;
                var buffer = new TextEncoder('utf-8').encode(JSON.stringify(model));
                var self = this;
                var HMAC = {name: "HMAC", hash: {name: 'SHA-256'}};
                window.crypto.subtle.generateKey(HMAC, true, ['sign', 'verify'])
                        .then(function (key) {
                            console.log('Crypto key : ', key);
                            window.crypto.subtle.exportKey('jwk', key).then(function (jwk) {
                                console.log('jwk : ', jwk);
                            });
                            return window.crypto.subtle.sign(HMAC, key, buffer).then(function (mac) {
                                var decoder = new TextDecoder('latin1');
//                                var decodedString = window.btoa(decoder.decode(mac));
//                                var decodedString = self.arrayBufferToBase64(mac);
//                                 var decodedString = btoa(String.fromCharCode.apply(self, mac));
                                var decodedString = self.toHexString(mac);
                                console.log('compute HMAC : ', mac);
                                console.log('size HMAC : ', new Uint8Array(mac).length);
                                console.log('compute HMAC : ', decodedString);
                                return mac;
                            }).catch(function (err) {
                                console.error(err);
                            });
                        });

//                var promise = this._generateCryptoKey().then(function (key) {
//                    console.log('Crypto key : ', key);
//                    return cryptoSubtle.sign("HMAC", key, buffer).then(function (mac) {
//                        console.log('compute HMAC : ', mac);
//                        self.orderId = mac;
//                        self.$.orderDB.save();
//                    });
//                });
//                promise.then(function (mac) {
//                    console.log('compute HMAC : ' ,mac);
//                    self.orderId = mac;
//                    return self.$.orderDB.save();
//                });
//                .catch(function (err) {
//                            console.log(err);
//                });

            },

        });
    </script>
</dom-module>
